<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Afrika No Dako</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      overflow: hidden;
    }
    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      background-color: lightblue;
      overflow: hidden;
    }
    .point {
      width: 160px;
      height: 160px;
      background-color: black;
      position: absolute;
      border-radius: 50%;
    }
    #score {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 36px;
      font-weight: bold;
      color: orangered;
    }
    #water {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 48px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div id="score">Score: 0</div>
    <div id="water">ðŸ’¦</div>
  </div>
  <script>
    const gameContainer = document.getElementById('gameContainer');
    const scoreElement = document.getElementById('score');
    const water = document.getElementById('water');
    const waterX = gameContainer.clientWidth / 2 - 24; // Ajuste la position du centre du jeu
    const waterY = gameContainer.clientHeight - 84; // Ajuste la position du centre du jeu

    let score = 0;
    let baseInterval = 2000;
    const minInterval = 300; // DÃ©finir l'intervalle minimum Ã  300 ms

    function createPoint() {
      const point = document.createElement('div');
      point.classList.add('point');
      point.style.top = '0px';
      point.style.left = Math.random() * (gameContainer.clientWidth - 160) + 'px';
      gameContainer.appendChild(point);

      let speed = Math.random() * 3 + 2;
      let directionX = (waterX - parseFloat(point.style.left)) / (gameContainer.clientHeight / speed);
      
      point.isRemoved = false; // Ajout d'une propriÃ©tÃ© pour suivre l'Ã©tat de suppression

      function movePoint() {
        if (point.isRemoved) return; // Ne pas continuer si le point est supprimÃ©
        
        const currentTop = parseFloat(point.style.top);
        const currentLeft = parseFloat(point.style.left);

        if (currentTop + speed > gameContainer.clientHeight) {
          alert('Game Over! Votre score est : ' + score);
          location.reload();
        } else {
          point.style.top = currentTop + speed + 'px';
          point.style.left = currentLeft + directionX + 'px';
          requestAnimationFrame(movePoint);
        }
      }

      point.addEventListener('click', () => {
        score++;
        scoreElement.textContent = 'Score: ' + score;
        point.isRemoved = true; // Marquer le point comme supprimÃ©
        point.remove();
        adjustInterval(); // Ajuster l'intervalle aprÃ¨s chaque clic
      });

      requestAnimationFrame(movePoint);
    }

    function adjustInterval() {
      let newInterval = baseInterval / Math.pow(1.05, score); // RÃ©duction exponentielle de l'intervalle
      if (newInterval < minInterval) newInterval = minInterval; // Ne pas descendre en dessous du minimum
      clearInterval(intervalId);
      intervalId = setInterval(spawnPoints, newInterval); // Appliquer le nouvel intervalle
    }

    function spawnPoints() {
      const chance = Math.random();
      if (chance < 0.01) {
        createPoint(); createPoint(); createPoint(); // 1 % de chances que 3 points apparaissent
      } else if (chance < 0.30) {
        createPoint(); createPoint(); // 29 % de chances que 2 points apparaissent
      } else {
        createPoint(); // 70 % de chances que 1 point apparaisse
      }
    }

    function checkCollision() {
      const points = document.getElementsByClassName('point');
      for (const point of points) {
        const currentTop = parseFloat(point.style.top);
        if (!point.isRemoved && currentTop + point.clientHeight > gameContainer.clientHeight) {
          alert('Game Over! Votre score est : ' + score);
          location.reload();
        }
      }
    }

    let intervalId = setInterval(spawnPoints, baseInterval);

    setInterval(checkCollision, 50); // VÃ©rifie les collisions toutes les 50ms
  </script>
</body>
</html>
